<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaScript 筆記整理]]></title>
    <url>%2F2019%2F06%2F30%2Fjavascript%2F</url>
    <content type="text"><![CDATA[整理記錄 JavaScript 相關的筆記連結。 基礎知識JavaScript：Hoisting (宣告提升)JavaScript：this (基礎)JavaScript：this (進階)ES6ES6：解構賦值]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML 5：語意標籤]]></title>
    <url>%2F2019%2F06%2F30%2Fhtml5-tag%2F</url>
    <content type="text"><![CDATA[HTML 5 的語意標籤概念。 語意與非語意標籤常見的 div 就是典型的非語意標籤， 過往在 Layout 排版時，會透過設定常見的 class 名稱，來區分板塊上的位置。12&lt;div class=&quot;header&quot;&gt;&lt;/div&gt;&lt;div class=&quot;footer&quot;&gt;&lt;/div&gt; 到了 HTML 5 的版本後，原先通用常見的 class 命名，被加入到標籤，而這些新增的標籤，透過英文可以直接了解到其對應的區塊，因此也被稱為語意標籤。12&lt;header&gt;&lt;/header&gt;&lt;footer&gt;&lt;/footer&gt; 優點透過語意標籤，可以精簡化程式碼，不需要特別使用 div + class，此外對搜尋引擎優化(SEO)有更好的輔助效果，結構如下。1234567&lt;header&gt;標題&lt;/header&gt;&lt;nav&gt;Nav選單&lt;/nav&gt;&lt;main&gt; &lt;article&gt;文章內容&lt;/article&gt; &lt;aside&gt;側邊欄&lt;/aside&gt;&lt;/main&gt;&lt;footer&gt;底部&lt;/footer&gt; 若需要針對語意標籤處理樣式時，可以在 CSS 中使用標籤選擇器。123header &#123; color: blue;&#125;]]></content>
      <tags>
        <tag>HTML 5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript：this (進階)]]></title>
    <url>%2F2019%2F06%2F30%2Fjavascript-this-advanced%2F</url>
    <content type="text"><![CDATA[JavaScript 中的函式綁定物件 this 進階知識。]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript：this (基礎)]]></title>
    <url>%2F2019%2F06%2F30%2Fjavascript-this-basic%2F</url>
    <content type="text"><![CDATA[JavaScript 中的函式綁定物件 this 基礎知識。 基本觀念this 代表函式的綁定物件，通常在函式中使用。但在不同程式碼狀況下，綁定物件會代表不同東西。 情境一：獨立的函式當 this 使用在函式時，會指向 HTML DOM 中最上層的 window 物件。也就因此能指向 window 底下的對象，譬如視窗的寬 innerWidth。12345function demo () &#123; console.log(this) console.log(innerWidth)&#125;demo() 情境二：物件在物件中，this 會被指向物件本身，因此物件中有的屬性或值，都可以被 this 指向，並且進行操作，例如使用 console 印出來。12345678let obj = &#123; a: 2, demo: function () &#123; console.log(this) console.log(this.a) // 印出 2 &#125;&#125;obj.demo() 情境三：事件處理函式在事件中使用 this，其本身就是觸發事件的對象，譬如綁定在 button 上，就會觸發 button。而當現在未綁定時，就會指向 document。1234document.addEventListener(&apos;click&apos;, function () &#123; console.log(this) this.body.innerHTML = &apos;Clicked&apos;&#125;) 情境四：建構函式在建構式當中，this 會是瀏覽器自動幫我們新建立好的空白物件。因此當我們在其中進行賦值時，相對也就會塞進物件中。1234567function Point () &#123; console.log(this) this.a = 5 this.b = 10&#125;let test = new Point()console.log(test)]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang 入門]]></title>
    <url>%2F2019%2F06%2F30%2Fgolang-started%2F</url>
    <content type="text"><![CDATA[記錄 Golang 的基礎知識、環境安裝和快速開始。 基本特性泛用性程式語言，可用於開發各種應用，側重強調效能，有更強的乘載能力。同時相對於傳統的 C、C++，學習成本更低。]]></content>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面試問題整理：CSS]]></title>
    <url>%2F2019%2F06%2F29%2Finterview-css%2F</url>
    <content type="text"><![CDATA[CSS 基礎知識問題整理。 Q1：什麼是選擇器?CSS 選擇器常見分為四種，同時根據權重差異，決定彼此的優先級。 行內樣式(inline)，直接在 HTML 添加樣式，權重最重(1000) 1&lt;p style=&quot;color:red&quot;&gt;Hello&lt;/p&gt; ID 選擇器，權重次之(100) 1#header 最常用的 class，包含偽類、屬性，權重(10) 1.wrap、:hover、[attribute] 元素選擇器(即 HTML 元素本身)、偽元素，權重(1) 1p、h1、em、::after Q2：盒模型剛開始學寫 CSS 時，會面臨一個問題，當元素加入 padding、margin、border 時，邊距會導致 px 的數值差異，初期為了解決這個問題，常需要特別去加加減減數字，這樣對開發實在不友善。 為了改善這個問題，引入 box-sizing: border-box。讓寬度只計算內容本身 + padding + border。因此我們通常建議在初始化樣式時，加入到 *。123* &#123; box-sizing: border-box;&#125; Q3：margin 垂直覆蓋屬性margin 的特性中，當兩個元素為垂直時，會產生覆蓋重疊的問題。例如兩個 p 標籤，設定 margin 為 5px，理論上應該是 5px + 5px = 10px，但因為重疊的關係，實際上只有 5px，另外，如果兩個 tag 大小不一的話，大的一方會蓋掉小的一方。]]></content>
      <tags>
        <tag>面試</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[實作：串接 OpenWeather API]]></title>
    <url>%2F2019%2F06%2F26%2Fopenweathermap-api%2F</url>
    <content type="text"><![CDATA[實作串接 OpenWeather API。 申請帳號OpenWeatherMap 官網 準備 iconfont awesome icon 4.7 cdn1https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css search icon1&lt;i class=&quot;fa fa-search&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; 寫入 HTML12345678910&lt;div class=&quot;center&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;header&gt; &lt;div class=&quot;search&quot;&gt; &lt;input type=&quot;text&quot; placeholder=&quot;Enter City Name&quot; id=&quot;search-txt&quot;&gt; &lt;a href=&quot;#&quot; id=&quot;search-btn&quot;&gt;&lt;i class=&quot;fa fa-search&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/i&gt;&lt;/a&gt; &lt;/div&gt; &lt;/header&gt; &lt;/div&gt;&lt;/div&gt;]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6：解構賦值]]></title>
    <url>%2F2019%2F06%2F23%2Fes6-destructuring%2F</url>
    <content type="text"><![CDATA[輕便且快速地取出元素：解構賦值。 陣列解構若有一個陣列如下1let numArray = [2, 4, 6] 可以透過下面兩種方法進行解構1234567// 方法一let [subNode, subItem] = numArray// 方法二let subNodelet subItem[subNode, subItem] = numArray 這兩種方法，都會拿到相同結果。當陣列解構後，就可以進行一般運算或處理。12let res = subNode * subItemconsole.log(res) // 印出8 預設值如果無法預期拿到陣列內容為何？透過預設值，可以避免缺少值的問題。例如：12345let numArray = [2, 4]let [first, second, third] = numArrayfirst + second + third // 這邊做計算的話，會產生 NaN 但如果透過預設值為0，則能避免上面的問題1let [first, second, third = 0] = numArray 忽略元素意指，僅調用陣列中某一元素。可以透過前面的值為空，但逗號保留的方式來進行忽略元素。12345let numArray = [2, 4, 8, 10]let [, , , item] = numArrayconsole.log(item) 變數交換透過陣列的形式，進行陣列解構的變數交換123456let a = 2;let b = 4;[a, b] = [b, a]console.log(a) // 印出 4console.log(b) // 印出 2 剩餘部分重組去除原始陣列中部分元素，透過 ... 的方式，將剩餘的元素重組成新陣列。12345let numArray = [1, 3, 5, 7, 9]let [first, ...node] = numArrayconsole.log(node) // 印出 [3, 5, 7, 9] 物件解構類似陣列解構，將變數快速賦值。12345678let itemObj = &#123; a: 10, b: 20&#125;let &#123;a, b&#125; = itemObjconsole.log(a) // 印出 10console.log(b) // 印出 20 物件解構，同樣可以給予預設值。1let &#123;a, b, c = 0&#125; = itemObj 改變變數名稱，解構時，冒號左側的 key 值必須維持和物件中相同，但右側可以命名新的變數。1234567let itemObj = &#123; a: 10, b: 35&#125;let &#123;a:x, b:y&#125; = itemObjconsole.log(y) // 印出 35 解構函式透過解構傳進來的參數，精簡程式碼1234function distance(point) &#123; let &#123;x, y&#125; = point return Math.sqrt(x*x + y*y)&#125; 但是解構函式，更進階的用法是，在參數內直接解構123function distance(&#123;x, y&#125;) &#123; return Math.sqrt(x*x + y*y)&#125; 因此既能給予預設值123function distance(&#123;x = 0, y&#125;) &#123; return Math.sqrt(x*x + y*y)&#125; 也能重新命名123function distance(&#123;x:a, y&#125;) &#123; return Math.sqrt(a*a + y*y)&#125;]]></content>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript：Hoisting (宣告提升)]]></title>
    <url>%2F2019%2F06%2F23%2Fjavascript-hoisting%2F</url>
    <content type="text"><![CDATA[記錄關於 Hoisting (宣告提升) 的知識點。 JavaScript 流程在一般的理解中，JavaScript 的語法運行流程，應該是先宣告變數，並進行賦值，最後印出變數的值。12var a = 5console.log(a) // 印出 5 特性因為 JavaScript 本身具有 Hoisting (宣告提升) 的特性，即使程式碼順序不正確。JavaScript 在檢視的過程中，會自動將宣告的變數提升至前面，促使程式可以正常執行。123item = 10console.log(item) // 印出10var item 但是 Hoisting 的特性在於宣告提升，而不影響賦值，所以如果把賦值放到後面，則會拿到 undefined。12console.log(item)var item = 10 JavaScript 實際運行時，會拿到下面的結果，自然也就印出 undefined。123var itemconsole.log(item) // 印出 undefineditem = 10 函式JavaScript 在函式，依然具有 Hoisting(宣告提升)的特性，所以下述的程式碼依然能夠執行。1234test()function test () &#123; console.log(&apos;Hello!&apos;)&#125; 但是，如果將函式賦值給變數，同樣會因為只有變數被提升，導致後面函式出現 is not defined1234test()var a = function test () &#123; console.log(&apos;Hello!&apos;)&#125;]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面試問題整理：JavaScript]]></title>
    <url>%2F2019%2F06%2F22%2Finterview-javascript%2F</url>
    <content type="text"><![CDATA[JavaScript 基礎知識問題整理。 Q1：直接輸入 console.log(a) 會印出什麼？1Uncaught ReferenceError: a is not defined JavaScript 是一種弱型別語言，宣告變數時，不需要先聲明類型。但如果沒有先建立變數的情況下，自然也會出現 ReferenceError。 Q2：JavaScript 目前有幾種型別？javascript 目前定義了七種型別，包含如下：1234567number - 數字，譬如 123string - 字符串，譬如：&apos;Hello&apos;boolean - 布林，true、falsenullundefinedobject - 物件，&#123;name: pitt&#125;、[12, 34, 56]、functionsymbol(ES6 新增的型別) 這七種型別可以區分為兩大類，分別是基本型別和物件型別，除了 object 外，其他都是基本型別。 Q3：let a = &quot;5&quot; * &quot;4&quot;，console.log(a) 會印出什麼？120 JavaScript 在 number 型別中，可以很好理解一般數學的四則運算，但是在 string 中，則會有些特別。string 相加時，會印出兩個字符串。12let a = &apos;2&apos; + &apos;2&apos;console.log(a) // 印出 &apos;22&apos; 但是 string 進行減法、乘法、除法時，則會進行一般數學計算。12let b = &apos;3&apos; * &apos;3&apos;console.log(b) // 印出 9 12let c = &apos;10&apos; - &apos;5&apos;console.log(c) // 印出 5 12let d = &apos;20&apos; / &apos;2&apos;console.log(d) // 印出 10 Q4：let item = &#39;1&#39; == &#39;10&#39; || &#39;2&#39; == &#39;2&#39;，console.log(item) 印出什麼？1true 其實這題沒什麼懸念，只是某次看到時，不知道大腦哪根神經接錯，竟然填 false，因此順手紀錄下來，避免下次再次犯錯。|| 即指滿足一邊條件即可，反之 &amp;&amp; 則須滿足所有條件。 因此，let item = &#39;1&#39; == &#39;10&#39; &amp;&amp; &#39;2&#39; == &#39;2&#39; 則印出 false。 Q5：第一行 function 是否能夠順利執行？1234numChange()function numChange() &#123; let num = 10&#125; 1基於 JavaScript 的 Hoisting(宣告提升) 特性，能夠執行。 JavaScript：Hoisting(宣告提升) Q6：下面 splice 方法會得出什麼結果？1234567var colorLength = [ &apos;yellow&apos;, &apos;blue&apos;, &apos;red&apos;]colorLength.splice(1, 1)console.log(colorLength) 12// 印出[&apos;yellow&apos;, &apos;red&apos;] 在 splice 方法中，第一個參數為起始位置，從哪一個位置開始刪除。第二個參數則為結束位置，如果不填，則從起始位置後面全部刪除。1234colorLength.splice(1)// 印出[&apos;yellow&apos;] 如果第二個參數填0，則不刪除任何值。1234colorLength.splice(1, 0)// 印出[&quot;yellow&quot;, &quot;blue&quot;, &quot;red&quot;] 第三個參數為可選，若有填值，則會加入原陣列中。1234colorLength.splice(2, 2, white)// 印出[&quot;yellow&quot;, &quot;blue&quot;, &quot;white&quot;] Q7：如何用 JavaScript 原生方法實作回上頁的功能？123可以調用兩種方法：1. window.history.back // 回到上一頁2. window.history.go(-1) // 指定回到上一頁，若傳入參數為 -2，則指定回到上二頁]]></content>
      <tags>
        <tag>面試</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tab 選項卡切換內容(下)]]></title>
    <url>%2F2019%2F06%2F17%2Ftab-change-down%2F</url>
    <content type="text"><![CDATA[施工中]]></content>
      <tags>
        <tag>Vue</tag>
        <tag>頁面邏輯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[實作：簡單留言本 (React)]]></title>
    <url>%2F2019%2F06%2F16%2Freact-textcontent-demo%2F</url>
    <content type="text"><![CDATA[初步摸索 React 相關的基礎知識，簡單記錄一點實作的過程，方便日後查看。 配置開發環境install 官方腳手架工具 create-react-appGithub 網址 全域安裝1yarn add create-react-app -g 啟動 demo1create-react-app react-textcontent-demo 運行1cd react-textcontent-demo 1yarn start 第一個組件建立 Hello.jsmkdir src/Hello.js 寫入 Hello React 內容123456789import React from &apos;react&apos;class Hello extends React.Component &#123; render () &#123; return &lt;h1&gt; Hello React &lt;/h1&gt; &#125;&#125;export default Hello 引入到 src/index.js 引入 1import Hello from &apos;./Hello&apos; 掛載，此時可以看到畫面渲染出 Hello React 的畫面。 1ReactDOM.render(&lt;Hello /&gt;, document.getElementById(&apos;root&apos;)); JSX 語法JSX 語法是一種語法糖，近似於 JavaScript 的語法擴充，放棄模板語言的形式，採用更語意化可讀性更強的標籤。並且使用 {} 內嵌任何 JavaScript 表達式。 e.g. 計算屬性如下，JSX 會計算出 3 這個數字，並渲染到頁面上。123456789101112131415import React from &apos;react&apos;class Hello extends React.Component &#123; render () &#123; const todoList = [&apos;Learning React&apos;, &apos;Learning English&apos;] return ( &lt;div&gt; &lt;h1&gt; Hello React &lt;/h1&gt; &#123; 1+2 &#125; &lt;/div&gt; ) &#125;&#125;export default Hello e.g. 使用 JSX 遍歷陣列12345678910111213141516171819202122import React from &apos;react&apos;class Hello extends React.Component &#123; render () &#123; const todoList = [&apos;Learning React&apos;, &apos;Learning English&apos;] return ( &lt;div&gt; &lt;h1&gt; Hello React &lt;/h1&gt; &#123;/* 使用JSX語法處理陣列 */&#125; &lt;ul&gt; &#123; todoList.map(node =&gt; &lt;li&gt;&#123;node&#125;&lt;/li&gt; ) &#125; &lt;/ul&gt; &lt;/div&gt; ) &#125;&#125;export default Hello e.g. 三元表達式：狀態判斷 (條件返回)JSX 語法也能使用在表達式12345678910111213141516import React from &apos;react&apos;class Hello extends React.Component &#123; render () &#123; const isLogin = false return ( &lt;div&gt; &lt;h1&gt; Hello React &lt;/h1&gt; &#123;/* 三元表達式 */&#125; &#123; isLogin ? &lt;p&gt;已經登入&lt;/p&gt; : &lt;p&gt;尚未登入&lt;/p&gt; &#125; &lt;/div&gt; ) &#125;&#125;export default Hello JSX 特例因為 class &amp; for 已經被 JavaScript 關鍵字佔用，因此需使用特例 使用 className 代替 class 1&lt;div className=&quot;style&quot;&gt; Hello World &lt;/div&gt; 使用 htmlFor 代替 for 1&lt;label for=&apos;male&apos;&gt;Male&lt;/label&gt; 組件書寫特性自定義 component 首字需大寫，這樣 JSX 才能識別為自定義還是原始 HTML 標籤。 Props 屬性組件近似於函式，接受特定的輸入 (props)，產出特定的輸出 (React elements)。 透過實例理解 propse.g. NameCard安裝 UI 框架 Bootstrap1yarn add bootstrap 在 src/components 寫好 NameCard.js 的組件，並引入到 src/app.js。透過 props 從 app.js 傳值給 NameCard.js，而 NameCard.js 則負責渲染資料並佈局樣式。 需要注意的是，props 接受傳值後具有唯讀的特性，不可更改。 函數式寫法目前 React 除了過往的 Class 寫法，也可以改成函數式寫法。12345678import React from &apos;react&apos;const NameCard = (props) =&gt; &#123; const &#123;&#125; = props return ()&#125;export default NameCard 簡單實現一個點讚+1的功能同樣的，先建立組件 src/components/likesButton，並引入到 app.js。 下面是已完成的 code，透過 constructor 建立初始化數據庫 state，接著在頁面搭建 increaseLikes 函式。 這邊需注意幾個要點：React 中，事件採用駝峰式命名，例如 onClick。javascript 的 class 中，this 是不會自動綁定的，需要手動綁定。state 數據庫不允許直接操作，需要透過 setState 方法。123456789101112131415161718192021222324252627282930313233import React from &apos;react&apos;class LikesButton extends React.Component &#123; constructor (props) &#123; super(props) this.state = &#123; likes: 0 &#125; // 在 javascript 的 class 中，this 是不會自動綁定的，需要手動綁定 this.increaseLikes = this.increaseLikes.bind(this) &#125; increaseLikes () &#123; // state 數據庫不允許直接操作，需要透過 setState 方法 this.setState((node) =&gt; (&#123; likes: node.likes += 1 &#125;)) &#125; render () &#123; return ( &lt;div className=&quot;likes-btn&quot;&gt; &lt;button type=&quot;button&quot; className=&quot;btn btn-outline-primary btn-bg&quot; onClick=&#123;this.increaseLikes&#125; &gt; &#123;this.state.likes&#125; 👍 &lt;/button&gt; &lt;/div&gt; ) &#125;&#125;export default LikesButton]]></content>
      <tags>
        <tag>React</tag>
        <tag>Demo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tab 選項卡切換內容(上)]]></title>
    <url>%2F2019%2F06%2F16%2Ftab-change-up%2F</url>
    <content type="text"><![CDATA[使用 tab 切換顯示內容，是常見的功能，記錄一下目前工作用的 tab 選項卡寫法。 準備 tab 列表這個列表可能是 API 給的值，也可能是前端自己組的靜態陣列，使用 v-for 語法渲染整個陣列。 index.vue template 1.tabTitle(v-for=&quot;(node, index) in itemList&quot;) 初始化一個用於點擊切換 tab 的參數 filter，並且初始化 tab 陣列 123456data () &#123; return &#123; filter: 0, itemList: [] &#125;&#125; 當頁面一進入時，就必須呼叫 API 函式，將取得的值傳入 tab 陣列 123created () &#123; this.ListService()&#125; methods 取得 API 的值 12345678getItemList () &#123; ListService.getItemList() .then((res) =&gt; &#123; this.itemList = res &#125;).catch((err) =&gt; &#123; console.log(err.message) &#125;)&#125; API 約定格式 12345678910result: [ &#123; name: &quot;選項一&quot;, data: [&#123;&#125;] &#125;, &#123; name: &quot;選項二&quot;, data: [&#123;&#125;] &#125;] 這時就能從 template 上，渲染出 tab 列表。 這邊多了一個 filterChange 的函式，用於執行點擊時，切換下方內容。 1234// 先用長度檢查 res 回傳是否正確.tabTitle(v-if=&quot;itemList.length &gt; 0&quot;) template(v-for=&quot;(node, index) in itemList&quot;) a.tabLink(@click=&quot;filterChange(index)&quot;) &#123;&#123;node.name&#125;&#125; methods 1234filterChange (index) &#123; this.filter = index this.subItemList = this.itemList[index].data&#125; 此處需修正，待補充名稱轉換通常 API 取回來的值，不一定符合前端需求，可能是英文或是數字，這時可以透過建立一個 formatter 函式來進行轉換。 準備轉換用的靜態對照表建立在 src/configs/site.js 中。1234export const TYPE = [ &#123; name: &apos;第一個名稱&apos;, value: &apos;0&apos;&#125;, &#123; name: &apos;第二個名稱&apos;, value: &apos;1&apos;&#125;] 回到 index.vue ，在 script 中引入對照表。1import &#123; TYPE &#125; from &apos;@/configs/site&apos; 並在 methods 中準備 formatter 函式。12345nameFormatter (val) &#123; let target = TYPE.find(node =&gt; node.value === val) if (target) return target.name else return val&#125; 渲染到 template 上。123.tabTitle(v-if=&quot;itemList.length &gt; 0&quot;) template(v-for=&quot;(node, index) in itemList&quot;) a.tabLink(@click=&quot;filterChange(index)&quot;) &#123;&#123;nameFormatter(node.name)&#125;&#125; tab 點擊切換時，進行樣式變化幾乎無可避免，tab 切換時會被要求添加樣式來改善使用體驗。 透過 v-bind 綁定 classdata 中存有初始化的變數 filter ，這組參數將作為判斷機制，當點擊事件觸發時，filter 也隨之變化。當 filter === 陣列中的 index ，則觸發綁定 active class。 style.scss準備 tab 列表本身每個欄位的樣式，並事先給予一個偽元素 after 作為切換時變化用的樣式。但是先將 width 設為 0 使其不顯示。當 active 被觸發時，則將 after 偽元素賦予 width 的值，此時便可以正常顯示，同時也能做一些樣式的改變，達到點擊切換時樣式變化的效果。12345678910111213141516171819202122232425262728293031323334.tabLink &#123; position: relative; display: flex; align-items: center; justify-content: center; padding: 0 10px; height: 100%; font-size: 13px; white-space: nowrap; color: $base; flex-direction: column; cursor: pointer; &amp;.active &#123; font-weight: bold; color: $danger; &amp;::after &#123; width: 100%; &#125; &#125; &amp;::after &#123; @include position(absolute, n, 0, 0, 0); z-index: index($z-index, base); display: flex; width: 0; height: 2px; background-color: $danger; transition: .5s ease all; content: &quot;&quot;; &#125;&#125;]]></content>
      <tags>
        <tag>Vue</tag>
        <tag>頁面邏輯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node 環境搭建(新電腦)]]></title>
    <url>%2F2019%2F06%2F16%2Fnode-environment%2F</url>
    <content type="text"><![CDATA[環境搭建是件挺麻煩的事情，很常踩到各種坑，記錄一下近期安裝流程。方便下次快速排查問題。 安裝 HomebrewHomebrew 是 mac 套件管理工具，透過它來安裝 nvm Homebrew 官網 安裝指令1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 安裝 nvmNode.js 的版本更迭速度很快，為了有效率管理 Node 版本，使用 nvm 工具進行 Node 版本切換與安裝。 nvm github curl 安裝 nvm 1curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash Homebrew 安裝 nvm 1brew install nvm 測試 nvm 是否安裝成功1nvm --version 但這時 iterm 另開分頁，測試nvm --version，有極大機率會nvm: command not found，所以為了解決這個問題，需要修改.bash_profile文件。 編輯 .bash_profile 文件1vi .bash_profile 複製下列代碼進入文件後，按 i 切換到修改模式，將複製的代碼貼上。12export NVM_DIR=&quot;$HOME/.nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; . &quot;$NVM_DIR/nvm.sh&quot; 按 esc 退出修改模式，接著按 :wq 保存修改後的結果。 生效1source .bash_profile 安裝 Node使用 nvm 指令查詢並安裝 node 查詢遠端 node 版本1nvm ls-remote 安裝需要的 node 版本1nvm install v11.15.0 切換需要使用的 node 版本1nvm use v11.15.0 設定預設使用的 node 版本1nvm alias default v11.15.0]]></content>
      <tags>
        <tag>node</tag>
        <tag>nvm</tag>
        <tag>環境</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[簡單實現 ProgressBar 效果]]></title>
    <url>%2F2019%2F06%2F12%2FprogressBar%2F</url>
    <content type="text"><![CDATA[記錄工作上，ProgressBar 的實現方式，以及如何結合API，達到推進的效果。 頁面結構準備一條當基底背景的 ProgressBar index.vue( 此處使用 Pug ) 1span.graph style.scss 123456789// ProgressBar 的寬高、背景色或 border-radius，依設計需求調整。.graph &#123; display: flex; width: 85%; height: 6px; background-color: #e6f8f9; border-radius: $radius;&#125; 準備一條產生前進變化的 ProgressBar index.vue template 12span.graph i.line(v-if=&quot;node.content&quot; :style=&quot;&#123;width:lineWidth(node.content.rate)&#125;&quot;) methods 123lineWidth (item) &#123; return item + &apos;%&apos;&#125; style.scss 1234567891011121314.graph &#123; display: flex; width: 85%; height: 6px; background-color: #e6f8f9; border-radius: $radius; .line &#123; display: flex; height: 100%; background-image: linear-gradient(to right, #ffeafe, #ccc1ff, #9ea9f0); border-radius: $radius; &#125;&#125; 運作邏輯負責執行前進變化的 ProgressBar，除去 width 之外，height 和 border-radius 必須和第一條 ProgressBar 相同，背景色則必須有所不同，才能出現覆蓋，達到前進的效果。 接著，問題在於，如何讓 width 出現動態變化。透過 API 取得的值，傳參給函式 lineWidth()，在函式中將值進行轉換並 return，如此便達到 ProgressBar 會隨著 API 取回的值產生前進變化。]]></content>
      <tags>
        <tag>Vue</tag>
        <tag>頁面邏輯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next 設定]]></title>
    <url>%2F2019%2F01%2F08%2Fhexo-theme-next%20%E8%A8%AD%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[記錄 Hexo 的 theme，Next 樣式調整的值。 調整路徑位置themes/next/_config.yml右側回到頂部 button 是否開啟百分比數字1scrollpercent: true]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>hexo-theme-next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nvm 常用指令]]></title>
    <url>%2F2019%2F01%2F08%2Fnvm-instruction%2F</url>
    <content type="text"><![CDATA[記錄常用 nvm 指令。 查詢遠端可安裝的 node 版本1nvm ls-remote 安裝所需的版本號1nvm install v10.15.0 切換所需使用的 node 版本1nvm use v10.15.0 設定預設使用的 node 版本1nvm alias default v10.15.0]]></content>
      <tags>
        <tag>nvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-Cli 3.0 Demo]]></title>
    <url>%2F2019%2F01%2F08%2FVue-Cli%203.0%20Demo%2F</url>
    <content type="text"><![CDATA[vue-cli 3.0 版本已經釋出一段時間，考慮到後續工作專案會開始採用，也必須著手實作了解一下。Vue-Cli 官網 與 2.0 版本差異1231. 新增GUI介面，可以不需使用指令。2. 更好的兼容支援TypeScript。3. 傳統在2.0版本的webpack配置，在GUI介面除了可使用下拉選擇方式，也多了更多的說明介紹。 安裝流程12345// 安裝方式(須移除舊版本Vue-Cli 1.x or 2.x)npm uninstall vue-cli -g# oryarn global remove vue-cli 123456// 前置要求：Node版本最低需8.9或更高(官方推薦8.11.0以上)// 安裝指令npm install -g @vue/cli# oryarn global add @vue/cli 1234567// 確認是否install成功，檢查版本號vue --version# orvue -V# 2019/1/8 v3.3.0 測試兩種專案結果1234567A專案是以vue-cli 2.x版本時建立移除vue-cli 2.x 並安裝vue-cli 3.0後create B專案，再回頭重新以3.0環境啟動A專案，可正常運行差別在於2.x版本的啟動指令仍是yarn run dev而3.0則改用yarn serve 兩種創建專案方式(command-line || GUI)command-line1vue create 專案名稱 選擇預設套件或是手動選擇12// 第一次在3.0環境建立專案時，僅有上述兩種選項// 當建立過一次模板環境後，可以選擇save，在第二次建立時，可以選用 依需求選擇安裝項目1按 space 選擇需安裝的項目 ESlint選規範版本 每次儲存時檢查代碼規範或commit時檢查 安裝在package.json內或獨立安裝 是否保存這次建立的選項(提供下次專案直接套用) GUI 創建(建議暫時擱置不使用，尚未穩定)1234// 安裝完成vue-cli 3.0環境後，輸入指令vue ui// 家中 mac 測試，GUI 工具會有持續 loading 的 error 問題// 查官方 issues 這一類的問題相當多，3.0.0 版本時全域安裝core.js可解 資料夾結構12345vue-cli 3.0 版本對應的是 webpack4.0 以上版本。因為官方不希望開發者花費過多精力調整webpack設定，因此統一移入node_modules 路徑如下：12345node_modules/@vue/cli-service/webpack.config.js// Service.jsnode_modules/@vue/cli-service/lib/Service.js 引入路徑名稱123456// 在 3.0 版本需注意引入路徑名稱和2.x有所差異e.g.import HelloWorld from &apos;@/components/HelloWorld.vue&apos;副檔名中.vue 在 3.0 版本不可被省略。 index.html1過往會被放在根目錄下，3.0 版本改至 public 下 測試打包1yarn build]]></content>
      <tags>
        <tag>Vue</tag>
        <tag>vue-cli</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node 版本路徑修復]]></title>
    <url>%2F2019%2F01%2F03%2Fnode-version-fixed%2F</url>
    <content type="text"><![CDATA[近期公司 MIS 調整硬體設備，造成環境有點跑掉，記錄一下自己在 stackoverflow 上找到的解法。打開 iTerm 會出現下述 error。12nvm is not compatible with the npm config “prefix” option: currently set to “/Users/xxx/.nvm/versions/node/v8.12.0&quot;Run `npm config delete prefix` or `nvm use --delete-prefix v8.12.0 --silent` to unset it. 從字面上來看，應該是 npm 和 nvm 管理的 node 版本沒有對上，按照終端機提供的訊息，敲入對應指令。 再檢查 node 版本似乎是正常了，但事實上，若在 iTerm 上另開分頁，依然會跳相同的提示錯誤。 雖然不影響操作，但看到總是不順眼，google 了一下解法，最終測試成功方案如下：12npm config delete prefixnpm config set prefix $NVM_DIR/versions/node/v8.12.0 看起來應該是先刪除 npm 中設定的 prefix ，再重新設定當前 nvm 使用的版本。 附上 stackoverflow 找到的解法。]]></content>
      <tags>
        <tag>Node</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 踩坑記]]></title>
    <url>%2F2019%2F01%2F03%2Ffixed-error%2F</url>
    <content type="text"><![CDATA[動手安裝 Hexo 過程中踩了一些坑，順手記錄自己 google 到的解法。 hexo g 生成路徑錯誤導致樣式跑版1234567891011121314151617hexo g 是 hexo 打包的指令，但若未調整生成路徑，則會出現打包後檔案路徑錯誤，導致開啟時，整個樣式跑版。要解決這個問題，需打開 _config.yml檢查 url 和 root 兩個項目以部署到 github-page 為例：url 為專案所在位置：https://wuzhe0912.github.io/PittWu-Hexo/root 則填上專案名稱：/PittWu-Hexo/完成修改後，重整 github-page，即可修正樣式錯誤問題。 Next 主題背景動畫配置無效果123456789101112Next 在5.x版本時，設定背景動畫效果，僅需在 _config.yml 調整 true or false 即有效果。但在6.X版本，不知道因為何種原因，這種設置方式完全失效。因此改採用下述三個步驟設置動畫效果。e.g. 選擇 canvas_nest 這個效果1. cd themes/next2. git clone https://github.com/theme-next/theme-next-canvas-nest source / lib / canvas-nest3. next/_config.yml 設定 enable: true其他三種動畫效果，同前述。]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 安裝筆記]]></title>
    <url>%2F2019%2F01%2F02%2Fhexo-install-note%2F</url>
    <content type="text"><![CDATA[記錄一下，自己安裝 Hexo 作為 Blog 的流程步驟。 選擇主題 挑選 Hexo 主題網址 選擇 Next 主題 12cd 資料夾git clone https://github.com/theme-next/hexo-theme-next themes/next 修改網站設定_config.yml 1theme: next 重新啟動 server 1hexo s Scheme 設定Next 有四種 Scheme 可以選擇，預設主題風格是 Muse。 在themes/next/_config.yml中找到 scheme 設定，再將想選擇的註釋去除即可。 個人選擇 Pisces。 12345# Schemes# scheme: Muse# scheme: Mistscheme: Pisces# scheme: Gemini 關於作者新增大頭貼 建立存放圖片用的資料夾1mkdir source/image 將大頭貼的照片丟入資料夾source/images 接著在主題設定themes/next/_config.yml中，設定大頭貼路徑。 12avatar: url: /images/avatar.jpeg 修改作者名稱 在_config.yml中設定姓名、標題和副標題12345678# Sitetitle: 無哲的隨手筆記subtitle:description:keywords:author: Pitt Wulanguage: zh-twtimezone: 動畫效果Next 主題提供數種背景動畫效果，themes/next/_config.yml供使用者選擇。 12345e.g. 選擇 canvas_nest 這個效果1. cd themes/next2. git clone https://github.com/theme-next/theme-next-canvas-nest source / lib / canvas-nest3. next/_config.yml 設定 enable: true Tags 分類 透過標籤將文章進行分類 新建一個頁面，用於保存所有 tag1hexo new page &quot;tags&quot; 接著將 type 設定為 “tags”12345---title: All tagsdate: 2019-01-03 22:48:09type: &quot;tags&quot;--- 之後，所有的文章皆能加入對應的標籤e.g.12345---title: Hexo 安裝筆記date: 2019-01-02 10:28:37tags: Hexo--- 關於我既然是 Blog 自然需要一頁 about 用於自我介紹。1hexo new page &quot;about&quot; 在themes/next/_config.yml中預設有 menu 欄位，將需要的欄位前方註解去除。123456789menu: home: / || home about: /about/ || user tags: /tags/ || tags #categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 開啟社群帳號連結在themes/next/_config.yml中可以新增個人社群網站連結。123456789101112social: GitHub: https://github.com/wuzhe0912 || github E-Mail: mailto:kgb00128@gmail.com || Gmail #Weibo: https://weibo.com/yourname || weibo #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skype 文章預覽在themes/next/_config.yml中，可以透過字數設定來才切預覽。123auto_excerpt: enable: false length: 150 也可以透過&lt;!--more--&gt;來裁切，在&lt;!--more--&gt;以上的文字，會出現在預覽。 文章搜索安裝插件1yarn add hexo-generator-searchdb 在根目錄的_config.yml中，添加下述內容12345search: path: search.xml field: post format: html limit: 10000 再到主題themes/next/_config.yml中設定為 true12local_search: enable: true 嵌入圖片因為已經在根目錄中，將post_asset_folder設為 true，因此每次 new post 都會有對應的料夾。為了便於管理，我們文章的圖片自然會放在對應的資料夾。 圖片嵌入的格式1&#123;% asset_img space-select.png %&#125; Google SEO (待添加)獲取 Google Site Verification Code登入Google Search Console，並輸入 Github-Page 網址。 在themes/next/_config.yml中填入驗證碼1google_site_verification: ooxx 安裝 sitemap 插件安裝hexo-sitemap-generator-sitemap123yarn add hexo-generator-sitemap# ornpm install hexo-generator-sitemap --save 在_config.yml中調整設定 右上角添加 Github Fork 圖片在themes/next/layout/_layout.swig中，找到下述代碼：123&lt;header id=&quot;header&quot; class=&quot;header&quot; itemscope itemtype=&quot;http://schema.org/WPHeader&quot;&gt; &lt;div class=&quot;header-inner&quot;&gt;&#123;% include &apos;_partials/header/index.swig&apos; %&#125;&lt;/div&gt;&lt;/header&gt; 並在 header 標籤下方添加 Github Corner 超連結樣式123456789&lt;header id=&quot;header&quot; class=&quot;header&quot; itemscope itemtype=&quot;http://schema.org/WPHeader&quot;&gt; &lt;div class=&quot;header-inner&quot;&gt;&#123;% include &apos;_partials/header/index.swig&apos; %&#125;&lt;/div&gt; &lt;a href=&quot;https://github.com/wuzhe0912&quot; class=&quot;github-corner&quot; target=&quot;_blank&quot; title=&quot;Follow me on GitHub&quot; aria-label=&quot;Follow me on GitHub&quot;&gt; &lt;svg width=&quot;80&quot; height=&quot;80&quot; viewBox=&quot;0 0 250 250&quot; style=&quot;fill:#42b983; color:#fff; position: absolute; top: 0; border: 0; right: 0;&quot; aria-hidden=&quot;true&quot;&gt; &lt;path d=&quot;M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2&quot; fill=&quot;currentColor&quot; style=&quot;transform-origin: 130px 106px;&quot; class=&quot;octo-arm&quot;&gt;&lt;/path&gt; &lt;path d=&quot;M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z&quot; fill=&quot;currentColor&quot; class=&quot;octo-body&quot;&gt;&lt;/path&gt; &lt;/svg&gt; &lt;/a&gt;&lt;/header&gt; 再到themes/next/source/css/_custom.styl添加樣式代碼123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108/* GitHub Cornor */.github-corner :hover .octo-arm &#123; animation: octocat-wave 560ms ease-in-out;&#125;@media (max-width: 991px) &#123; .github-corner &gt;svg &#123; fill: #42b983 !important; color: #fff !important; &#125; .github-corner .github-corner:hover .octo-arm &#123; animation: none; &#125; .github-corner .github-corner .octo-arm &#123; animation: octocat-wave 560ms ease-in-out; &#125;&#125;@-moz-keyframes octocat-wave &#123; 0%, 100% &#123; -webkit-transform: rotate(0); -moz-transform: rotate(0); -ms-transform: rotate(0); -o-transform: rotate(0); transform: rotate(0); &#125; 20%, 60% &#123; -webkit-transform: rotate(-25deg); -moz-transform: rotate(-25deg); -ms-transform: rotate(-25deg); -o-transform: rotate(-25deg); transform: rotate(-25deg); &#125; 40%, 80% &#123; -webkit-transform: rotate(10deg); -moz-transform: rotate(10deg); -ms-transform: rotate(10deg); -o-transform: rotate(10deg); transform: rotate(10deg); &#125;&#125;@-webkit-keyframes octocat-wave &#123; 0%, 100% &#123; -webkit-transform: rotate(0); -moz-transform: rotate(0); -ms-transform: rotate(0); -o-transform: rotate(0); transform: rotate(0); &#125; 20%, 60% &#123; -webkit-transform: rotate(-25deg); -moz-transform: rotate(-25deg); -ms-transform: rotate(-25deg); -o-transform: rotate(-25deg); transform: rotate(-25deg); &#125; 40%, 80% &#123; -webkit-transform: rotate(10deg); -moz-transform: rotate(10deg); -ms-transform: rotate(10deg); -o-transform: rotate(10deg); transform: rotate(10deg); &#125;&#125;@-o-keyframes octocat-wave &#123; 0%, 100% &#123; -webkit-transform: rotate(0); -moz-transform: rotate(0); -ms-transform: rotate(0); -o-transform: rotate(0); transform: rotate(0); &#125; 20%, 60% &#123; -webkit-transform: rotate(-25deg); -moz-transform: rotate(-25deg); -ms-transform: rotate(-25deg); -o-transform: rotate(-25deg); transform: rotate(-25deg); &#125; 40%, 80% &#123; -webkit-transform: rotate(10deg); -moz-transform: rotate(10deg); -ms-transform: rotate(10deg); -o-transform: rotate(10deg); transform: rotate(10deg); &#125;&#125;@keyframes octocat-wave &#123; 0%, 100% &#123; -webkit-transform: rotate(0); -moz-transform: rotate(0); -ms-transform: rotate(0); -o-transform: rotate(0); transform: rotate(0); &#125; 20%, 60% &#123; -webkit-transform: rotate(-25deg); -moz-transform: rotate(-25deg); -ms-transform: rotate(-25deg); -o-transform: rotate(-25deg); transform: rotate(-25deg); &#125; 40%, 80% &#123; -webkit-transform: rotate(10deg); -moz-transform: rotate(10deg); -ms-transform: rotate(10deg); -o-transform: rotate(10deg); transform: rotate(10deg); &#125;&#125; 重新啟動服務1hexo s 文章閱讀人數統計參考諸多前輩的做法後，採用 LeanCloud 的服務。 LeanCloud 建立一個新帳號後，進入控制台，創建一個新的應用。 點擊已創建的應用，會進入應用的控制頁面。 接著點選創建Class，選擇限制寫入 點選左側設置，進入應用 Key，複製 App ID 和 App Key， 並貼到themes/next/_config.yml1234leancloud_visitors: enable: false app_id: #&lt;app_id&gt; app_key: #&lt;app_key&gt; 參考資源小蛇蛇的筆記hoxis’ blogJohn Wu’s Blog]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
